php <- document / '' `
    case Node of
        <<>> -> [];
        _ -> Node
    end
`;

document <- (!init_tag .)* code literal_block? / (!init_tag .)+ `
    case Node of 
        [TextLeft, [Type, Code, _EndTag], Chunk] ->
            Label = case Type of
                init_tag when Code =:= [] -> [];
                init_tag -> #eval{statements=Code};
                init_tag_value -> Code
            end,
            case iolist_to_binary(TextLeft) of
                <<>> -> [];
                FinalText -> [#print_text{text=FinalText}]
            end ++
            lists:flatten([Label|Chunk]);
        Text ->
            [#print_text{text=iolist_to_binary(Text)}]
    end
`;

code <- code_normal / code_expr ~;

code_normal <- init_tag_code space? statements space? `
    [Init,_,Code,_] = Node,
    [Init,Code,end_tag]
`;

code_expr <- init_value space? expression space? (literal_block / end_tag)+ `
    [Init,_,CodeOne,_,End] = Node,
    Code = [ print(CodeOne) | End ],
    [Init,Code,end_tag]
`;

%% Tags

init_tag <- init_value / init_common / init_reduced ~;
init_tag_code <- init_common / init_reduced ~;

init_common  <- '<\?php' `init_tag`;
init_reduced <- '<\?'    `init_tag`;
init_value   <- '<\?='   `init_tag_value`;

end_tag      <- '\?>'    `end_tag`;

%% Comments

comment_c <- '/*' (!'*/' .)+ '*/' `
    []
`;

comment_cpp <- '//' (!('\n' / end_tag) .)+ '\n'? `
    []
`;

comment_shell <- '#' (!('\n' / end_tag) .)+ '\n'? `
    []
`;

comment <- comment_shell / comment_c / comment_cpp ~;

%% Statements and Blocks

statements <- (comment / statement / literal_block) ( space? (comment / statement / literal_block) )* `
    [Statement, StatementsRaw] = Node,
    NewStatement = if
        is_tuple(Statement) -> [Statement];
        is_atom(Statement) -> [Statement];
        true -> Statement
    end,
    Statements = [ S || [_,S] <- StatementsRaw ],
    lists:flatmap(fun(S) -> 
        if 
            is_tuple(S) -> [S]; 
            is_atom(S) -> [S];
            true -> S 
        end
    end, [NewStatement] ++ Statements)
`;

statement_controlflow <- st_if / st_while / st_foreach / st_for / st_switch / st_do_while ~;

statement <- statement_controlflow / st_function / st_return / st_break / st_continue / st_arith_mono / assign / st_include / st_print / st_call_function / st_global / st_conditions ~;

literal_block <- (end_tag (document / code_expr) init_tag_code) / (end_tag (document / code_expr)) / end_tag `
    case Node of
        end_tag -> [];
        [_,[],_] -> [];
        [_,[]] -> [];
        [_,Document,_] -> 
            lists:flatten(Document);
        [_,Document] -> 
            lists:flatten(Document)
    end
`;

code_block <- '{' space? statements space? '}' `
    [_,_,St,_,_] = Node,
    St
`;

st_conditions <- conditions space? ';' `
    [Cond,_,_] = Node,
    Cond
`;

st_global <- global space var (',' space? var)* space? ';' `
    [_Global,_,Var,Vars|_] = Node,
    GVars = [ Var | [ V || [_,_,V] <- Vars ] ],
    {global, GVars}
`;

st_call_function <- call_function space? ';' `
    [Call,_,_] = Node,
    Call
`;

st_include <- (include_once / include / require_once / require) space expression space? ';' `
    [Type,_,Expr|_] = Node,
    {call, Type, [Expr]}
`;

st_print <- (st_print_fun / st_print_old) space? ';' `
    [Print|_] = Node,
    Print
`;

st_print_fun <- (print / echo) space? '(' space? expression space? ')' `
    [_Print,_,_,_,Expr|_] = Node,
    print(Expr)
`;

st_print_old <- (print / echo) space expression `
    [_Print,_,Expr|_] = Node,
    print(Expr)
`;

st_arith_mono <- arith_mono space? ';' `
    [Arith|_] = Node,
    Arith
`;

st_return <- return (space? ( '(' space? )? expression ( space? ')' )?)? space? ';' `
    case Node of
        [_Return,[_,_,Expr|_]|_] -> {return, Expr};
        _ -> {return, undefined}
    end
`;

st_break <- break space? ';' `
    break
`;

st_continue <- continue space? ';' `
    continue
`;

for_assignments <- base_assign ( space? ',' space? base_assign )* `
    [Assign,Assigns] = Node,
    [Assign | [ A || [_,_,_,A] <- Assigns ] ]
`;

st_for <- for space? '(' space? for_assignments space? ';' space? conditions space? ';' space? for_assignments space? ')' space? ( code_block / statement / ';' / error:(.*) ) `
    [_For,_,_,_,Init,_,_,_,Cond,_,_,_,Update,_,_,_,Code] = Node,
    CodeBlock = case Code of
        {error,Data} -> throw_error(enostatement, Index, Data);
        <<";">> -> undefined;
        _ -> Code
    end,
    #for{init=Init,conditions=Cond,update=Update,loop_block=CodeBlock}
`;

switch_case <- ((case space (number / expr_string)) / default) space? ':' space? statements `
    case Node of 
    [[_Case,_,Label],_,_,_,St] -> 
        {switch_case, Label, St};
    [_Default,_,_,_,St] ->
        {default, St}
    end
`;

st_switch <- switch space? '(' space? expression_cond space? ')' space? '{' ( space? switch_case space?)+ space? '}' `
    [_Switch,_,_,_,Cond,_,_,_,_,Cases,_,_] = Node,
    {switch, Cond, [ Case || [_,Case,_] <- Cases ]}
`;

st_foreach <- foreach space? '(' space? var space as (space var space? '=>')? space? var space? ')' space? ( code_block / statement / ';' / error:(.*) ) `
    [_Foreach,_,_,_,List,_,_As,KeyOpt,_,Element,_,_,_,St] = Node,
    case St of
        {error,Data} -> throw_error(enostatement, Index, Data);
        <<";">> -> undefined;
        _ -> ok
    end,
    case KeyOpt of
        [] -> #foreach{iter=Element,elements=List,loop_block=St};
        [_,Key,_,_] -> #foreach{kiter=Key,iter=Element,elements=List,loop_block=St}
    end
`;

st_do_while <- do space? ( code_block / statement / error:(.*) ) space? while space? conditions_use space? ';' `
    [_Do,_,St,_,_While,_,Cond,_,_] = Node,
    case St of
        {error,Data} -> throw_error(enostatement, Index, Data);
        _ -> ok
    end,
    #while{type=post, conditions=Cond, loop_block=St}
`;

st_while <- while space? conditions_use space? ( code_block / statement / ';' / error:(.*) ) `
    [_While,_,Cond,_,St] = Node,
    CodeBlock = case St of
        {error,Data} -> throw_error(enostatement, Index, Data);
        <<";">> -> undefined;
        _ -> St
    end,
    #while{type=pre, conditions=Cond, loop_block=CodeBlock}
`;

st_if <- st_if_else / st_if_simple ~;

st_if_else <- st_if_simple space? else space? ( code_block / statement / error:(.*) ) `
    [#if_block{}=IfBlock,_,_Else,_,ElseSt] = Node,
    case ElseSt of
        {error,Data} -> throw_error(enostatement, Index, Data);
        _ -> ok
    end,
    IfBlock#if_block{false_block=if
        is_list(ElseSt) -> ElseSt;
        true -> [ElseSt]
    end}
`;

st_if_simple <- if space? conditions_use space? ( code_block / statement / error:(.*) ) `
    [_If,_,Cond,_,St] = Node,
    case St of
        {error,Data} -> throw_error(enostatement, Index, Data);
        _ -> ok
    end,
    #if_block{conditions=Cond, true_block=if
        is_list(St) -> St;
        true -> [St]
    end}
`;

st_function <- function space key space? '(' space? (var (space? ',' space? var)* space?)? ')' space? code_block `
    {{line,Line},{column,_}} = Index,
    case Node of
        [_Func,_,Name,_,_,_,[],_,_,Clauses] ->
            Clause = {clause,Line,[],[],Clauses},
            {function,Line,binary_to_atom(Name, utf8),0,Clause};
        [_Func,_,Name,_,_,_,[Var,Vars,_],_,_,Clauses] ->
            Args = [Var | [ V || [_,_,_,V] <- Vars ]],
            Arith = length(Args),
            Clause = {clause,Line,Args,Clauses},
            {function,Line,binary_to_atom(Name,utf8),Arith,Clause}
    end
`;

%% Assign

composed_assign <- var space? assign_op space? expression `
    {{line,Line},{column,_}} = Index,
    [Var,_,Type,_,Expr] = Node,
    {call,Line,{atom,Line,put},[
        Var, {op,Line,Type,
            {call,Line,{atom,Line,get},Var},
            Expr
        }
    ]}
`;

base_assign <- arith_mono / composed_assign / (var space? '=' space? (base_assign / expression)) `
    {{line,Line},{column,_}} = Index,
    case Node of
        [Var,_,_Eq,_,Expr] -> {call,Line,{atom,Line,put},[Var, Expr]};
        MonoArith -> MonoArith
    end
`;

assign <- space? base_assign space? ';' `
    [_,Assign,_,_] = Node,
    Assign
`;

%% Conditions

conditions_use <- '(' space? conditions space? ')' `
    [_,_,Cond,_,_] = Node,
    Cond
`;

conditions <- condition space? nexo space? conditions / cs:condition `
    {{line,Line},{column,_}} = Index,
    case Node of 
        [A,_,Type,_,B] -> {op,Line,Type,A,B};
        {cs, Param} -> Param
    end
`;

condition <- primary_cond space? comparator space? cs:condition / not? pri:primary_cond `
    {{line,Line},{column,_}} = Index,
    case Node of
        [A,_,Type,_,{cs,B}] -> {op,Line,Type,A,B};
        [Not, {pri, Param}] -> case Not of
            [] -> Param;
            'not' -> {op,Line,'not',Param}
        end
    end 
`;

primary_cond <- ("(" space? cs:conditions space? ")") / expression_cond `
    if
        is_tuple(Node) -> Node;
        is_list(Node) -> proplists:get_value(cs, Node)
    end
`;

%% Expressions

expression_cond <- array_def / expr_string / boolean / null / st_include / st_print_old / st_print_fun / call_function / arith_mono / additive / number / var / constant ~;

expression <- array_def / expr_string / boolean / null / call_function / arith_mono / ternary / additive / conditions / number / var / constant ~;

%% Others

ternary <- conditions space? '\?' space? expression (space? ':' space? expression)? `
    case Node of
        [Cond,_,_,_,St,[]] -> #if_block{
            conditions=Cond, 
            true_block=St};
        [Cond,_,_,_,St,[_,_,_,ElseSt]] -> #if_block{
            conditions=Cond, 
            true_block=St, 
            false_block=ElseSt}
    end
`;

call_function <- (key / var) space? '(' (space? expression (space? ',' space? expression)*)? space? ')' `
    {{line,Line},{column,_}} = Index,
    {FuncName, Arguments} = case Node of
        [Name,_,_,[_,Arg,Args],_,_] ->
            {Name, [Arg | [ A || [_,_,_,A] <- Args ]]};
        [Name,_,_,[],_,_] ->
            {Name, []}
    end,
    {call,Line,{atom,Line,FuncName},Arguments}
`;

% reserved words
if <- #(?i)if# `'if'`;
else <- #(?i)else# `else`;
while <- #(?i)while# `while`;
for <- #(?i)for# `for`;
foreach <- #(?i)foreach# `foreach`;
as <- #(?i)as# `as`;
function <- #(?i)function# `function`;
break <- #(?i)break# `break`;
continue <- #(?i)continue# `continue`;
switch <- #(?i)switch# `switch`;
case <- #(?i)case# `'case'`;
default <- #(?i)default# `default`;
array <- #(?i)array# `array`;
print <- #(?i)print# `print`;
echo <- #(?i)echo# `print`;
do <- #(?i)do# `do`;
and <- #(?i)and# / '&&' `'and'`;
or <- #(?i)or# / '||' `'or'`;
not <- #(?i)not# / '!' `'not'`;
null <- #(?i)null# `null`;
true <- #(?i)true# `true`;
false <- #(?i)false# `false`;
return <- #(?i)return# `return`;
global <- #(?i)global# `global`;
include <- #(?i)include# `<<"include">>`;
include_once <- #(?i)include_once# `<<"include_once">>`;
require <- #(?i)require# `<<"require">>`;
require_once <- #(?i)require_once# `<<"require_once">>`;

mono_logic <- '~' ~;
mono_aritmetic <- '++' / '--' ~;
comparator <- eq / xeq / ne / xne / gt / geq / lt / leq ~;

assign_op <- assign_plus / assign_minus / assign_mul / assign_div ~;

assign_plus <- '+=' `'+'`;
assign_minus <- '-=' `'-'`;
assign_mul <- '*=' `'*'`;
assign_div <- '/=' `'/'`;

eq <- '==' `'=='`;
xeq <- '===' `'=:='`;

ne <- '!=' / '<>' `'!='`;
xne <- '!==' / '<=>' `'!=='`;

gt <- '>' `'>'`;
lt <- '<' `'<'`;

geq <- '>=' / '=>' `'>='`;
leq <- '<=' / '=<' `'=<'`;

boolean <- true / false ~;

nexo <- and / or ~;

space <- [ \t\n\s\r]+ ~;

% definitions

array_index <- arith_mono / ternary / string / additive ~;
array_element <- (array_index space? '=>' space?)? expression `
    case Node of
        [[I|_],Expr] -> #array_element{idx=I, element=Expr};
        [[],Expr] -> #array_element{element=Expr}
    end
`;

array_def <- array_def_func / array_def_simple ~;

array_def_simple <- '[' space? array_element tail:( space? ',' space? array_element )* space? ']' `
    [_,_,ArrayElement,{tail,Tail},_,_] = Node,
    ArrayElements = lists:foldr(fun([_,_,_,NewArrayElement], Elements) ->
        [NewArrayElement|Elements]
    end, [], Tail),
    #array{elements=[ArrayElement|ArrayElements]}
`;

array_def_func <- array space? '(' space? array_element tail:( space? ',' space? array_element )* space? ')' `
    [_Array,_,_,_,ArrayElement,{tail,Tail},_,_] = Node,
    ArrayElements = lists:foldr(fun([_,_,_,NewArrayElement], Elements) ->
         [NewArrayElement|Elements]
    end, [], Tail),
    #array{elements=[ArrayElement|ArrayElements]}
`;

number <- float / integer ~;

float <- '-'? space? [0-9]* '\.' [0-9]+ `
    {{line,Line},{column,_}} = Index,
    [Sign,_,Integer,_Dot,Decimal] = Node,
    IntegerBin = iolist_to_binary(Integer),
    DecimalBin = iolist_to_binary(Decimal),
    FloatStr = binary_to_list(<<IntegerBin/binary, ".", DecimalBin/binary>>),
    S = case Sign of
        <<"-">> -> -1;
        _ -> 1
    end,
    {float,Line,list_to_float(FloatStr) * S}
`;

integer <- '-'? space? [0-9]+ `
    {{line,Line},{column,_}} = Index,
    [Sign,_,Int] = Node,
    IntBin = iolist_to_binary(Int),
    IntList = binary_to_list(IntBin),
    S = case Sign of 
        <<"-">> -> -1;
        _ -> 1
    end,
    {integer,Line,list_to_integer(IntList) * S}
`;

constant <- key `
    case Node of
        <<"__LINE__">> -> 
            {{line,Line},{column,_}} = Index,
            {integer,Line,Line};
        _ ->
            % TODO: access to constant list to put the value directly
            #constant{name=Node}
    end
`;

key <- [a-zA-Z_] [a-zA-Z0-9_]* `
    {{line,Line},{column,_}} = Index,
    {bin,Line,[
        {bin,Line,{string,Line,iolist_to_binary(Node)},default,default}
    ]}
`;

var <- var_ref / var_array / var_simple ~;

var_ref <- '&' (var_array / var_simple) `
    [_,Var] = Node,
    {ref, Var}
`;

var_array <- '$' key ('[' space? (array_index space?)? ']')+ `
    [_Dollar, Key, Indexes] = Node,
    #variable{name=Key, idx=[ get_index(I) || [_,_,I,_] <- Indexes ]}
`;

var_simple <- '$' key `
    [_Dollar, Key] = Node,
    #variable{name=Key}
`;


%% math operations

arith_params <- number / call_function / var / logic_mono / arith_mono ~;

logic_mono <- mono_logic space? expression `
    {{line,Line},{column,_}} = Index,
    [_Op, _, Expr] = Node,
    {op,Line,'not',Expr}
`;

arith_mono <- pre:(mono_aritmetic space? var) / post:(var space? mono_aritmetic) `
    case Node of
        {pre, [Type,_,Var]} -> 
            case Type of
                <<"++">> -> {pre_incr, Var};
                <<"--">> -> {pre_decr, Var}
            end;
        {post, [Var,_,Type]} ->
            case Type of
                <<"++">> -> {post_incr, Var};
                <<"--">> -> {post_decr, Var}
            end
    end
`;

additive <- multitive space? ( "+" / "-" ) space? additive / mul:multitive `
    {{line,Line},{column,_}} = Index,
    case Node of 
        [A,_,Type,_,B] -> {op,Line,Type,A,B};
        {mul, Param} -> Param
    end
`;

multitive <- logical space? ( "*" / "/" / "%" ) space? mul:multitive / log:logical `
    {{line,Line},{column,_}} = Index,
    case Node of
        [A,_,Type,_,{mul,B}] -> {op,Line,Type,A,B};
        {log, Param} -> Param
    end 
`;

logical <- primary space? ( "^" / "|" / "&" ) space? log:logical / pri:primary `
    case Node of
        [A,_,Type,_,{log,B}] -> {op,Type,A,B};
        {pri, Param} -> Param
    end
`;

primary <- ("(" space? add:additive space? ")") / arith_params `
    if
        is_tuple(Node) -> Node;
        is_list(Node) -> proplists:get_value(add, Node)
    end
`;

%% strings

expr_string <- concat / string ~;

string <- string_fixed / string_parsed ~;

string_fixed <- "'" (!"'" ("\\\\" / "\\'" / .))* "'" `
    {{line,Line},{column,_}} = Index,
    [_,Text,_] = Node,
    {bin,Line,[
        {bin,Line,{string,Line,parse_string(Text)},default,default}
    ]}
`;

string_parsed <- '"' (!'"' ("\\\\" / '\\"' / var / .))* '"' `
    {{line,Line},{column,_}} = Index,
    [_,TextRaw,_] = Node,
    {Text,Total} = lists:foldr(fun
        ([[], <<L:1/binary>>], {Text,Total}) ->
            {<<L/binary,Text/binary>>,Total};
        ([[], Other], {Text,Total}) ->
            {<<>>, case Text of 
                <<>> -> [Other|Total];
                _ -> [Other,parse_string(Text)|Total]
            end}
    end, {<<>>,[]}, TextRaw),
    FinalText = case Text of
        <<>> -> Total;
        _ -> [parse_string(Text)|Total]
    end,
    case FinalText of
        [<<_/binary>>=FT] -> {bin,Line,[{bin,Line,{string,Line,FT},default,default}]};
        _ -> {text_to_process, FinalText}
    end
`;

concat_special <- '(' space? (arith_mono / ternary / additive / conditions) space? ')' `
    [_,_,Concat|_] = Node,
    Concat
`;

concat_types <- concat_special / boolean / null / array_def / string / call_function / number / var / constant ~;

concat <- concat_types (space? '\.' space? concat_types)+ `
    {{line,Line},{column,_}} = Index,
    [Str1,Strings] = Node,
    ParsedStrings = [Str1 | [ Str || [_,_,_,Str] <- Strings ]],
    Result = lists:foldr(fun
        (String, []) -> 
            [String];
        ({text,String}, [{bin,_,{string,_,PrevStr},_,_}|RestStr]) ->
            [{bin,Line,{string,Line,<<String/binary, PrevStr/binary>>},default,default}|RestStr];
        (String, RestStr) ->
            [String|RestStr]
    end, [], ParsedStrings),
    case Result of
        [{text, Str}] when is_binary(Str) -> {bin,Line,[{bin,Line,{string,Line,Str},default,default}]};
        _ -> {concat, Result}
    end
`;

%% Helpers and other code

`
-include("ephp.hrl").

throw_error(Error, Index, Data) ->
    Output = iolist_to_binary(Data),
    Size = min(byte_size(Output), 20),
    throw({error, Error, Index, <<Output:Size/binary, "...">>}).

print({Type, Value}) when
        Type =:= int; Type =:= float; Type =:= text ->
    #print_text{text=ephp_util:to_bin(Value)};
print(Value) when is_atom(Value) ->
    #print_text{text=ephp_util:to_bin(Value)};
print(Expr) ->
    #print{expression=Expr}.

parse_string(Text) ->
    parse_string(iolist_to_binary(Text), <<>>).

parse_string(<<>>, Result) ->
    Result;
parse_string(<<"\\\\",Rest/binary>>, Result) ->
    parse_string(Rest, <<Result/binary, $\\>>);
parse_string(<<"\\n",Rest/binary>>, Result) ->
    parse_string(Rest, <<Result/binary, $\n>>);
parse_string(<<"\\t",Rest/binary>>, Result) ->
    parse_string(Rest, <<Result/binary, $\t>>);
parse_string(<<"\\r",Rest/binary>>, Result) ->
    parse_string(Rest, <<Result/binary, $\r>>);
parse_string(<<C:1/binary,Rest/binary>>, Result) ->
    parse_string(Rest, <<Result/binary, C/binary>>).

get_index([I,_]) -> I;
get_index([]) -> auto.

`
